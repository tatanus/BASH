# =============================================================================
# MSSQL Login Scanner with Case-Insensitive Matching for `service` and `info`
# =============================================================================

# Include common helper functions and globals
resource /root/DATA/TOOLS/SCRIPTS/MSF/common_helpers.rc

<ruby>
# === CONFIGURATION
module_path = "auxiliary/scanner/mssql/mssql_login"
thread_count = "10"

target_filter = {
  proto: "tcp",
  ports: [1433],
  services: ["mssql", "ms-sql-s"],
  info: []  # Example: ["Microsoft SQL Server"]
}

user_file = "/root/DATA/TOOLS/SCRIPTS/MSF/FILES/SQL_USER.txt"
pass_file = "/root/DATA/TOOLS/SCRIPTS/MSF/FILES/SQL_PASS.txt"
module_name = module_path.split("/").last
tee_dir = "/root/DATA/OUTPUT/TEE"
tee_log_path = "#{tee_dir}/MSF_#{module_name}.tee"
success_log_path = "#{tee_dir}/MSF_SUCCESS.tee"

# === Ensure directories
ensure_tee_dir(tee_dir)

# === Initialize module
print_status("Using module: #{module_path}")
self.run_single("use #{module_path}")
self.run_single("set THREADS #{thread_count}")
self.run_single("set USER_FILE #{user_file}")
self.run_single("set PASS_FILE #{pass_file}")
self.run_single("spool #{tee_log_path}")

# === Target Loop
framework.db.hosts.each do |host|
  begin
    host.services.each do |service|
      # Filter on proto and state
      next unless service.proto == target_filter[:proto] && service.state == "open"

      # Exact match on service name (case-insensitive)
      service_name_match = target_filter[:services].map(&:downcase).include?(service.name.to_s.downcase)

      # Port match
      port_match = target_filter[:ports].include?(service.port)

      # Require either service name or port match
      next unless service_name_match || port_match

      # Optional: Substring match on service.info (case-insensitive)
      unless target_filter[:info].empty?
        info_match = target_filter[:info].any? do |needle|
          service.info.to_s.downcase.include?(needle.downcase)
        end
        next unless info_match
      end

      # Proceed with target
      print_status("Targeting #{host.address}:#{service.port} (#{service.name})")

      self.run_single("set RHOSTS #{host.address}")
      self.run_single("set RPORT #{service.port}")

      # Capture output for keyword check
      result = Rex::Ui::Text::Output::Buffer.new
      original_output = self.driver.output
      self.driver.output = result
      self.run_single("run")
      self.driver.output = original_output

      # Match output against success keywords
      if $success_keywords.any? { |kw| result.output.downcase.include?(kw) }
        print_good("Success detected on #{host.address}:#{service.port}")
        log_success(success_log_path, "[#{module_path}] #{host.address}:#{service.port} (#{service.name})")
      end
    end
  rescue => e
    print_error("Error processing host #{host.address}: #{e.message}")
  end
end

# === Cleanup
self.run_single("spool off")
self.run_single("back")
</ruby>

exit
