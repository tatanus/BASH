#!/usr/bin/env bash
set -uo pipefail

# =============================================================================
# NAME        : pentest.alias.sh
# DESCRIPTION :
# AUTHOR      : Adam Compton
# DATE CREATED: 2024-12-08 19:57:22
# =============================================================================
# EDIT HISTORY:
# DATE                 | EDITED BY    | DESCRIPTION OF CHANGE
# ---------------------|--------------|----------------------------------------
# 2024-12-08 19:57:22  | Adam Compton | Initial creation.
# =============================================================================

# Guard to prevent multiple sourcing
if [[ -z "${PENTEST_ALIAS_SH_LOADED:-}" ]]; then
    declare -g PENTEST_ALIAS_SH_LOADED=true

    # Alias to run 'nmap' with specific options for scanning open ports
    alias nmap='nmap --open -g53 --randomize-hosts --script-args http.useragent="Mozilla/5.0 (Windows NT 10.0; WOW64)"'

    # Alias to run 'enum4linux' with specific options for enumeration
    alias e4l="enum4linux -v -v -a "

    # Alias to include user status (disabled/enabled) when dumping hashes
    alias secretsdump='secretsdump.py -user-status'

    # function to grep hashes from secretsdump output
    function grep_secretsdump_hash() {
        # Check if input is provided via arguments or piped
        if [[ $# -gt 0 ]]; then
            # Use the input file(s) passed as arguments
            awk -F ":" '{print $1":"$2":"$3":"$4":::"}' "$@"
        else
            # Read from standard input if no arguments are passed
            awk -F ":" '{print $1":"$2":"$3":"$4":::"}'
        fi
    }

    # Alias to list all LSA Secrets
    alias lsa='cat ~/.{cme,nxc}/logs/*secrets | egrep -v "(RemoteDesktopHelpAssistant|sha1|md5)" | sort -fu'

    # Alias to list hosts that had LSA Secrets
    alias lsa_hosts='egrep -rav "(RemoteDesktopHelpAssistant|sha1|md5)" ~/.{cme,nxc}/logs/*secrets | sed -r s/_.*secrets// | cut -d ":" -f1 | sort -uf'

    # Alias to list LSA findings
    alias lsa_report='egrep --color=never -rav "(RemoteDesktopHelpAssistant|sha1|md5)" ~/.{cme,nxc}/logs/*secrets | sort -u'

    # Function to update pentest environment variables
    function update_pentest_env() {
        local field="$1"
        local value="$2"
        local pentest_env_file="${HOME}/.config/bash/pentest.env.sh"
        sed -i "s|export ${field}=.*|export ${field}='${value}'|g" "${pentest_env_file}"
    }

    # Function to clean up at the end of the engagement
    function end_engagement() {
        # Check if the backup directory exists and create it if necessary
        if [[ ! -d "${BACKUP_DIR}" ]]; then
            echo "Creating backup directory: ${BACKUP_DIR}"
            mkdir -p "${BACKUP_DIR}" || {
                                          echo "Failed to create backup directory."
                                                                                     return "${_FAIL}"
            }
        fi

        # Run "history" in each screen/tmux session and capture errors
        echo "Saving command history from screen and tmux sessions..."
        if ! exec_on_all_screen_sessions history; then
            echo "Warning: Failed to execute 'history' on screen sessions."
        fi

        if ! exec_on_all_tmux_sessions history; then
            echo "Warning: Failed to execute 'history' on tmux sessions."
        fi

        # Close all screen sessions
        echo "Closing all screen sessions..."
        if screen -ls | grep -q tached; then
            screen -ls | grep tached | cut -d. -f1 | awk '{ print $1 }' | xargs -r kill || echo "Warning: Failed to close some screen sessions."
        else
            echo "No active screen sessions found."
        fi

        # Close all tmux sessions
        echo "Closing all tmux sessions..."
        if tmux ls > /dev/null 2>&1; then
            tmux kill-server || echo "Warning: Failed to close tmux sessions."
        else
            echo "No active tmux sessions found."
        fi

        # Copy over engagement files to backup directory
        echo "Backing up engagement-related files..."
        declare -A source_dest_map=(
             ["${HOME}/.msf4"]="${BACKUP_DIR}/MSF"
             ["${HOME}/.cme"]="${BACKUP_DIR}/CME"
             ["${HOME}/.nxc"]="${BACKUP_DIR}/NXC"
             ["${HOME}/.manspider"]="${BACKUP_DIR}/MANSPIDER"
             ["${BASH_LOG_DIR}/.bash_commands.log"]="${BACKUP_DIR}/bash_history.log" # Copy as bash_history
             ["${HOME}/.pentest/pentest.log"]="${BACKUP_DIR}/pentest.log"
        )

        for source in "${!source_dest_map[@]}"; do
            dest="${source_dest_map["${source}"]}"

            if [[ -e "${source}" ]]; then
                echo "Copying ${source} to ${dest}..."
                cp -R "${source}" "${dest}" || echo "Warning: Failed to copy ${source} to ${dest}."
            else
                echo "Warning: Source ${source} does not exist, skipping."
            fi
        done

        # Compress all data into a tar.gz archive
        echo "Compressing all engagement data into a tar.gz file..."
        cd "${HOME}" || {
                          echo "Failed to switch to ${HOME} directory."
                                                                         return "${_FAIL}"
        }
        if [[ -d "DATA" ]]; then
            tar cvf data.tar DATA && gzip -f data.tar || echo "Failed to compress data.tar."
        else
            echo "Warning: DATA directory does not exist. Skipping compression."
        fi

        echo "Engagement cleanup completed successfully."
    }

    # Function to parse GNMAP file and create files per port
    parse_gnmap() {
        local gnmap_file="$1"
        local output_dir="$2"

        # Create the output directory if it doesn't exist
        mkdir -p "${output_dir}"

        # Check if the GNMAP file exists
        if [[ ! -f "${gnmap_file}" ]]; then
            echo "Error: GNMAP file not found!" >&2
            return 1
        fi

        # Extract lines with open ports and process them
        grep 'Ports:' "${gnmap_file}" | while read -r line; do
            # Extract the IP address
            local ip
            ip=$(echo "${line}" | awk '{print $2}')

            # Extract the FQDN, if present
            local fqdn
            fqdn=$(echo "${line}" | grep -oP '\(\K[^\)]*')

            # Extract open ports and iterate through them
            echo "${line}" | grep -oP '\d+/open' | cut -d'/' -f1 | while read -r port; do
                # Check if the port is valid
                if [[ -n "${port}" ]]; then
                    # Append the IP address to the respective port file
                    echo "${ip}" >> "${output_dir}/port_${port}.txt"

                    # Append the FQDN to the port file (if it exists)
                    if [[ -n "${fqdn}" ]]; then
                        echo "${fqdn}" >> "${output_dir}/port_${port}.txt"
                    fi
                fi
            done
        done

        # Sort and deduplicate each port file
        for file in "${output_dir}/port_"*.txt; do
            # Check if files exist before processing
            [[ -e "${file}" ]] || continue
            sort -u "${file}" -o "${file}"
        done

        echo "Parsing complete. Files created in: ${output_dir}"
    }

    # Function to block communication to excluded hosts/ranges using iptables
    function iptables_exclude() {
        # Check if the excludes.txt file exists
        if [[ ! -f "${ENGAGEMENT_DIR}/excludes.txt" ]]; then
            echo "Excludes file (${ENGAGEMENT_DIR}/excludes.txt) not found. Exiting."
            return "${_FAIL}"
        fi

        echo "Reading excluded hosts/ranges from ${ENGAGEMENT_DIR}/excludes.txt..."

        # Iterate through each line in excludes.txt
        while IFS= read -r exclude || [[ -n "${exclude}" ]]; do
            # Skip empty lines or lines that start with '#'
            if [[ -z "${exclude}" || "${exclude}" =~ ^# ]]; then
                continue
            fi

            # Check if the iptables rule already exists
            if iptables -C OUTPUT -d "${exclude}" -j REJECT 2> /dev/null; then
                echo "Rule for ${exclude} already exists. Skipping."
            else
                # Add an iptables rule to block the host/range
                echo "Adding iptables rule to block: ${exclude}"
                if ! iptables -A OUTPUT -d "${exclude}" -j REJECT; then
                    echo "Warning: Failed to add iptables rule for ${exclude}."
                fi
            fi
        done < "${ENGAGEMENT_DIR}/excludes.txt"

        # Display the current iptables OUTPUT chain
        echo "Current iptables OUTPUT chain:"
        if ! iptables -nvL OUTPUT; then
            echo "Failed to display iptables rules."
            return "${_FAIL}"
        fi

        echo "iptables_exclude completed successfully."
        return "${_PASS}"
    }

    # Function to mount a VMDK file and handle multiple partitions
    function VMDKmount() {
        # The VMDK file to be mounted is passed as the first argument
        local vmdk_file="$1"

        # Base directory where partitions will be mounted
        local base_mount_dir="${ENGAGEMENT_DIR:-/tmp}/TASKS/RECON/SHARES/VMDK"

        # Counter to handle multiple partitions and create unique mount directories
        local count=1

        # Check if the VMDK file path was provided
        if [[ -z "${vmdk_file}" ]]; then
            echo "Error: Usage: VMDKmount <vmdk_file>"
            return "${_FAIL}"
        fi

        # Ensure the specified VMDK file exists
        if [[ ! -f "${vmdk_file}" ]]; then
            echo "Error: VMDK file '${vmdk_file}' does not exist."
            return "${_FAIL}"
        fi

        # Ensure the base mount directory exists, create it if necessary
        if [[ ! -d "${base_mount_dir}" ]]; then
            mkdir -p "${base_mount_dir}" || {
                echo "Error: Failed to create base mount directory '${base_mount_dir}'."
                return "${_FAIL}"
            }
        fi

        # Identify partitions in the VMDK file using guestfish
        echo "Info: Identifying partitions in ${vmdk_file}..."
        local partitions
        partitions="$(guestfish --ro -a "${vmdk_file}" run : list-partitions 2> /dev/null)" || {
            echo "Error: Failed to list partitions in '${vmdk_file}'."
            return "${_FAIL}"
        }

        # Ensure at least one partition is available in the VMDK file
        if [[ -z "${partitions}" ]]; then
            echo "Error: No partitions found in '${vmdk_file}'."
            return "${_FAIL}"
        fi

        # Array to store successfully mounted partitions
        local mount_points=()

        # Loop through each partition and attempt to mount it
        while IFS= read -r partition; do
            # Create a unique mount directory for each partition
            local mount_dir="${base_mount_dir}_partition_${count}"

            # Warn if the directory already exists but is not mounted
            if [[ -d "${mount_dir}" ]]; then
                if ! mount | grep -q "on ${mount_dir} "; then
                    echo "Warning: Directory ${mount_dir} exists but is not used for mounting."
                fi
            fi

            # Create the mount directory if it does not already exist
            mkdir -p "${mount_dir}" || {
                echo "Error: Failed to create mount directory '${mount_dir}'."
                continue
            }

            # Attempt to mount the partition as read-only
            echo "Info: Attempting to mount partition: ${partition}"
            if guestmount -a "${vmdk_file}" -m "${partition}" --ro "${mount_dir}"; then
                echo "Success: Mounted ${partition} to ${mount_dir}"
                mount_points+=("${mount_dir}")  # Add the successful mount point to the array
            else
                echo "Error: Failed to mount partition: ${partition}"
                rmdir "${mount_dir}" 2> /dev/null # Remove the directory if mount fails
            fi

            # Increment the counter for the next partition
            count=$((count + 1))
        done <<< "${partitions}"

        # Check if any partitions were successfully mounted
        if [[ ${#mount_points[@]} -eq 0 ]]; then
            echo "Error: Failed to mount any partitions from '${vmdk_file}'."
            return "${_FAIL}"
        fi

        # Display success message with all mounted partitions
        echo "Success: Mounted the following partitions from ${vmdk_file}:"
        for mount_dir in "${mount_points[@]}"; do
            echo "  - ${mount_dir}"
        done

        # Provide guidance for accessing the mounted file systems
        echo "Info: Access mounted file systems. Example:"
        echo "  secretsdump.py -sam <mount_point>/Windows/System32/config/SAM \\"
        echo "                  -system <mount_point>/Windows/System32/config/SYSTEM local"

        return "${_PASS}"
    }

    # Function to unmount all VMDK partitions
    function VMDKunmount() {
        # The base mount directory to unmount is passed as the first argument
        local base_mount_dir="$1"

        # Check if the base mount directory was provided
        if [[ -z "${base_mount_dir}" ]]; then
            fail "Usage: VMDKunmount <base_mount_dir>"
            return "${_FAIL}"
        fi

        # Ensure the base directory exists
        if [[ ! -d "${base_mount_dir}" ]]; then
            fail "Directory '${base_mount_dir}' does not exist."
            return "${_FAIL}"
        fi

        # Find all subdirectories in the base mount directory
        local mount_dirs=("${base_mount_dir%/}/"*/)
        if [[ ${#mount_dirs[@]} -eq 0 ]]; then
            fail "No mounted partitions found in '${base_mount_dir}'."
            return "${_FAIL}"
        fi

        # Loop through each subdirectory and unmount it
        for mount_dir in "${mount_dirs[@]}"; do
            # Check if the directory is currently mounted
            if mount | grep -q "on ${mount_dir} "; then
                info "Unmounting ${mount_dir}..."
                guestunmount "${mount_dir}" || {
                    fail "Failed to unmount '${mount_dir}'."
                    continue
                }
                pass "Successfully unmounted ${mount_dir}."
            else
                # If not mounted, skip the directory
                info "No filesystem is mounted on '${mount_dir}'. Skipping."
            fi

            # Remove the directory if it is empty
            if [[ -d "${mount_dir}" && -z "$(find "${mount_dir}" -mindepth 1 -print -quit)" ]]; then
                rmdir "${mount_dir}" && pass "Removed empty mount directory: ${mount_dir}"
            fi
        done

        return "${_PASS}"
    }
fi
