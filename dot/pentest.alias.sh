#!/usr/bin/env bash
set -uo pipefail

# =============================================================================
# NAME        : pentest.alias.sh
# DESCRIPTION :
# AUTHOR      : Adam Compton
# DATE CREATED: 2024-12-08 19:57:22
# =============================================================================
# EDIT HISTORY:
# DATE                 | EDITED BY    | DESCRIPTION OF CHANGE
# ---------------------|--------------|----------------------------------------
# 2024-12-08 19:57:22  | Adam Compton | Initial creation.
# =============================================================================

# Guard to prevent multiple sourcing
if [[ -z "${PENTEST_ALIAS_SH_LOADED:-}" ]]; then
    declare -g PENTEST_ALIAS_SH_LOADED=true

    # Alias to run 'nmap' with specific options for scanning open ports
    alias nmap='nmap --open -g53 --randomize-hosts --script-args http.useragent="Mozilla/5.0 (Windows NT 10.0; WOW64)"'

    # Alias to run 'enum4linux' with specific options for enumeration
    alias e4l="enum4linux -v -v -a "

    # Alias to include user status (disabled/enabled) when dumping hashes
    alias secretsdump='secretsdump.py -user-status'

    # function to grep hashes from secretsdump output
    function grep_secretsdump_hash() {
        # Check if input is provided via arguments or piped
        if [[ $# -gt 0 ]]; then
            # Use the input file(s) passed as arguments
            awk -F ":" '{print $1":"$2":"$3":"$4":::"}' "$@"
        else
            # Read from standard input if no arguments are passed
            awk -F ":" '{print $1":"$2":"$3":"$4":::"}'
        fi
    }

    # Alias to list all LSA Secrets
    alias lsa='cat ~/.{cme,nxc}/logs/*secrets | egrep -av '\''(plain_password|RemoteDesktopHelpAssistant|sha1|md5|DPAPI_SYSTEM|aad3b435b51404eeaad3b435b51404ee|dpapi|NL\$KM|L\$|Unknown\ User|SysPrepIISInfo|SCM:|ASPNET:|Security\ Questions|Question:\ |Answer:\ |RasDial|Version : 1)'\'' | sort -fu'

    # Alias to list hosts that had LSA Secrets
    alias lsa_hosts='egrep -rav '\''(plain_password|RemoteDesktopHelpAssistant|sha1|md5|DPAPI_SYSTEM|aad3b435b51404eeaad3b435b51404ee|dpapi|NL\$KM|L\$|Unknown\ User|SysPrepIISInfo|SCM:|ASPNET:)'\'' ~/.{cme,nxc}/logs/*secrets | sed -r s/_.*secrets// | cut -d ":" -f1 | sed -r '\''s/.*\/(\S+)$/\1/'\'' | sort -uf'

    # Alias to list LSA findings
    alias lsa_report='egrep --color=never -rav '\''(\{[a-zA-Z0-9]{8}\-[a-zA-Z0-9]{4}\-[a-zA-Z0-9]{4}\-[a-zA-Z0-9]{4}\-[a-zA-Z0-9]{12}\}|RemoteDesktopHelpAssistant|sha1|md5|DPAPI_SYSTEM|plain_password|aad3b435b51404eeaad3b435b51404ee|dpapi|NL\$KM|L\$|Unknown\ User|SysPrepIISInfo|SCM:|ASPNET:)'\''~/.{cme,nxc}/logs/*secrets | sed '\''s/.*logs\/\(.*\)_[0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+_2020.*secrets:/\1\t/'\'' | sort -u'

    function get_hashes() {
        local responder_logs="${TOOLS_DIR}/Responder/logs/*.txt"
        local pcredz_hashes="${OUTPUT_DIR}/PCAP/hashes_ntlmv2"
        local ntlmrelayx_hashes="${OUTPUT_DIR}/PCAP/logs/NTLMv2.txt"

        local files_to_cat=()

        # Include Responder logs if any match
        if compgen -G "${responder_logs}" > /dev/null; then
            mapfile -t matched_logs < <(compgen -G "${responder_logs}")
            files_to_cat+=("${matched_logs[@]}")
        fi

        # Check and include hashes_ntlmv2
        if [[ -f "${pcredz_hashes}" ]]; then
            files_to_cat+=("${pcredz_hashes}")
        fi

        # Check and include NTLMv2.txt
        if [[ -f "${ntlmrelayx_hashes}" ]]; then
            files_to_cat+=("${ntlmrelayx_hashes}")
        fi

        # Proceed only if thereâ€™s something to process
        if [[ ${#files_to_cat[@]} -eq 0 ]]; then
            echo "No hash files found to process."
            return
        fi

        # Output processed hashes
        cat "${files_to_cat[@]}" 2> /dev/null \
            | sort_first \
            | grep -a -v "\\$:" \
            | grep -a -v -E "^::"
    }

    # Lists all dynamically added functions in the pentest alias file.
    function list_tools() {
        # Verify that PENTEST_ALIAS_FILE is set and readable
        if [[ -z "${PENTEST_ALIAS_FILE}" ]]; then
            echo "PENTEST_ALIAS_FILE is not set. Cannot list functions."
            return 1
        fi

        if [[ ! -r "${PENTEST_ALIAS_FILE}" ]]; then
            echo "PENTEST_ALIAS_FILE (${PENTEST_ALIAS_FILE}) is not readable."
            return 1
        fi

        # Extract function names that include "run_tools_command"
        local functions
        functions=$(awk '
            /^function / { func_name=$2; next }
            /run_tools_command/ { print func_name }
        ' "${PENTEST_ALIAS_FILE}" | sed 's/(.*//' | sort -u)

        if [[ -z "${functions}" ]]; then
            echo "No dynamically added functions found in ${PENTEST_ALIAS_FILE}."
            return 1
        fi

        pass "Functions found in ${PENTEST_ALIAS_FILE}:"
        echo "${functions}"

        return 0
    }

    # Executes a Python script within its virtual environment.
    # Dynamically determines the log file path based on the script name.
    function run_tools_command() {
        # Check if the required environment variables are set
        if [[ -z "${TOOLS_DIR:-}" || -z "${OUTPUT_DIR:-}" ]]; then
            echo "[ERROR] TOOLS_DIR and OUTPUT_DIR must be set as environment variables." >&2
            return 1
        fi

        # Validate that the first argument (cmd_path) is provided
        if [[ $# -lt 1 ]]; then
            echo "[ERROR] Usage: run_tools_command <cmd_path> [args...]" >&2
            return 1
        fi

        local cmd_path="$1"
        shift

        # Ensure the provided script path exists and is a file
        if [[ ! -f "${cmd_path}" ]]; then
            echo "[ERROR] The script path '${cmd_path}' does not exist or is not a file." >&2
            return 1
        fi

        # Extract the script name (without extension) for log file naming
        local base_name
        base_name=$(basename "${cmd_path}")
        base_name="${base_name%.*}" # Remove the file extension if it exists
        local log_file="${OUTPUT_DIR}/TEE/${base_name}.tee"

        # Determine the appropriate interpreter if needed
        local interpreter=""
        case "$(basename "${cmd_path}")" in
            *.py)
                # Dynamically determine the Python binary in the venv/bin/ directory
                local venv_dir
                venv_dir="$(dirname "${cmd_path}")/venv/bin"

                # Check if the venv directory exists
                if [[ ! -d "${venv_dir}" ]]; then
                    interpreter="python3.10 -u"
                else
                    # Find the Python binary in the venv directory
                    local venv_python
                    venv_python=$(find -L "${venv_dir}" -type f -name "python*" -exec file {} \; | grep -i "python" | awk -F: '{print $1}' | head -n 1)

                    # Check if a valid Python binary was found
                    if [[ -z "${venv_python}" ]]; then
                        echo "[ERROR] No Python binary found in virtual environment directory '${venv_dir}'." >&2
                        return 1
                    fi

                    interpreter="${venv_python} -u"
                fi
                ;;
            *.rb)
                interpreter="ruby"
                ;;
            *.sh)
                interpreter="bash"
                ;;
            *.pl)
                interpreter="perl"
                ;;
            *)
                # No extension or unsupported extension, try running directly
                interpreter=""
                ;;
        esac

        # # If an interpreter is required, ensure it exists and is executable
        # if [[ -n "${interpreter}" && ! -x "$(command -v "${interpreter}")" ]]; then
        #     echo "[ERROR] Interpreter '${interpreter}' not found or not executable." >&2
        #     return 1
        # fi

        # Change to the script's directory
        pushd "$(dirname "${cmd_path}")" > /dev/null || {
            echo "[ERROR] Failed to change to the script directory '$(dirname "${cmd_path}")'." >&2
            return 1
        }

        # Set a trap to ensure popd is called even on interrupt (e.g., CTRL-C)
        trap "popd" EXIT

        # Execute the script with the interpreter (if any) and log the output
        if [[ -n "${interpreter}" ]]; then
            ${interpreter} "${cmd_path}" "$@" | tee -a "${log_file}"
        else
            "${cmd_path}" "$@" | tee -a "${log_file}"
        fi

        # Reset the trap on successful completion
        trap - EXIT

        # Return to the original directory
        popd > /dev/null || {
            echo "[WARNING] Failed to return to the original directory." >&2
        }

        return 0
    }

    # Function to update pentest environment variables
    function update_pentest_env() {
        local field="$1"
        local value="$2"
        local pentest_env_file="${HOME}/.config/bash/pentest.env.sh"
        sed -i "s|export ${field}=.*|export ${field}='${value}'|g" "${pentest_env_file}"
    }

    # Function to clean up at the end of the engagement
    function end_engagement() {
        # Check if the backup directory exists and create it if necessary
        if [[ ! -d "${BACKUP_DIR}" ]]; then
            echo "Creating backup directory: ${BACKUP_DIR}"
            if mkdir -p "${BACKUP_DIR}"; then
                echo "Backup directory created successfully."
            else
                echo "Error: Failed to create backup directory: ${BACKUP_DIR}."
                return "${_FAIL}"
            fi
        fi

        # Run "history" in each screen/tmux session and capture errors
        echo "Saving command history from screen and tmux sessions..."
        if ! exec_on_all_screen_sessions history; then
            echo "Warning: Failed to execute 'history' on screen sessions."
        fi

        if ! exec_on_all_tmux_sessions history; then
            echo "Warning: Failed to execute 'history' on tmux sessions."
        fi

        # Close all screen sessions
        echo "Closing all screen sessions..."
        if screen -ls | grep -q tached; then
            screen -ls | grep tached | cut -d. -f1 | awk '{ print $1 }' | xargs -r kill || echo "Warning: Failed to close some screen sessions."
        else
            echo "No active screen sessions found."
        fi

        # Close all tmux sessions
        echo "Closing all tmux sessions..."
        if tmux ls > /dev/null 2>&1; then
            tmux kill-server || echo "Warning: Failed to close tmux sessions."
        else
            echo "No active tmux sessions found."
        fi

        # Copy over engagement files to backup directory
        echo "Backing up engagement-related files..."
        declare -A source_dest_map
        source_dest_map["${HOME}/.msf4"]="${BACKUP_DIR}/MSF"
        source_dest_map["${HOME}/.cme"]="${BACKUP_DIR}/CME"
        source_dest_map["${HOME}/.nxc"]="${BACKUP_DIR}/NXC"
        source_dest_map["${HOME}/.manspider"]="${BACKUP_DIR}/MANSPIDER"
        source_dest_map["${BASH_LOG_DIR}/.bash_commands.log"]="${BACKUP_DIR}/bash_history.log" # Copy as bash_history
        source_dest_map["${HOME}/.pentest/pentest.log"]="${BACKUP_DIR}/pentest.log"

        for source in "${!source_dest_map[@]}"; do
            dest="${source_dest_map["${source}"]}"

            if [[ -e "${source}" ]]; then
                echo "Copying ${source} to ${dest}..."
                cp -R "${source}" "${dest}" || echo "Warning: Failed to copy ${source} to ${dest}."
            else
                echo "Warning: Source ${source} does not exist, skipping."
            fi
        done

        # Compress all data into a tar.gz archive
        echo "Compressing all engagement data into a tar.gz file..."

        # Change to the HOME directory
        if cd "${HOME}"; then
            if [[ -d "DATA" ]]; then
                # Create a tar archive and compress it
                if tar cvf data.tar DATA && gzip -f data.tar; then
                    echo "Compression successful: ${HOME}/data.tar.gz"
                else
                    echo "Error: Failed to compress data.tar."
                fi
            else
                echo "Warning: DATA directory does not exist. Skipping compression."
            fi
        else
            echo "Error: Failed to switch to ${HOME} directory."
            return "${_FAIL}"
        fi
    }

    # Function to parse GNMAP file and create files per port
    function parse_gnmap() {
        local gnmap_file="$1"
        local output_dir="$2"

        # Create the output directory if it doesn't exist
        mkdir -p "${output_dir}"

        # Check if the GNMAP file exists
        if [[ ! -f "${gnmap_file}" ]]; then
            echo "Error: GNMAP file not found!" >&2
            return 1
        fi

        # Extract lines with open ports and process them
        grep 'Ports:' "${gnmap_file}" | while read -r line; do
            # Extract the IP address
            local ip
            ip=$(echo "${line}" | awk '{print $2}')

            # Extract the FQDN, if present
            local fqdn
            fqdn=$(echo "${line}" | grep -oP '\(\K[^\)]*')

            # Extract open ports and iterate through them
            echo "${line}" | grep -oP '\d+/open' | cut -d'/' -f1 | while read -r port; do
                # Check if the port is valid
                if [[ -n "${port}" ]]; then
                    # Append the IP address to the respective port file
                    echo "${ip}" >> "${output_dir}/port_${port}.txt"

                    # Append the FQDN to the port file (if it exists)
                    if [[ -n "${fqdn}" ]]; then
                        echo "${fqdn}" >> "${output_dir}/port_${port}.txt"
                    fi
                fi
            done
        done

        # Sort and deduplicate each port file
        for file in "${output_dir}/port_"*.txt; do
            # Check if files exist before processing
            [[ -e "${file}" ]] || continue
            sort -u "${file}" -o "${file}"
        done

        echo "Parsing complete. Files created in: ${output_dir}"
    }

    # Function to block communication to excluded hosts/ranges using iptables
    function iptables_exclude() {
        # Check if the excludes.txt file exists
        if [[ ! -f "${ENGAGEMENT_DIR}/excludes.txt" ]]; then
            echo "Excludes file (${ENGAGEMENT_DIR}/excludes.txt) not found. Exiting."
            return "${_FAIL}"
        fi

        echo "Reading excluded hosts/ranges from ${ENGAGEMENT_DIR}/excludes.txt..."

        # Iterate through each line in excludes.txt
        while IFS= read -r exclude || [[ -n "${exclude}" ]]; do
            # Skip empty lines or lines that start with '#'
            if [[ -z "${exclude}" || "${exclude}" =~ ^# ]]; then
                continue
            fi

            # Check if the iptables rule already exists
            if iptables -C OUTPUT -d "${exclude}" -j REJECT 2> /dev/null; then
                echo "Rule for ${exclude} already exists. Skipping."
            else
                # Add an iptables rule to block the host/range
                echo "Adding iptables rule to block: ${exclude}"
                if ! iptables -A OUTPUT -d "${exclude}" -j REJECT; then
                    echo "Warning: Failed to add iptables rule for ${exclude}."
                fi
            fi
        done < "${ENGAGEMENT_DIR}/excludes.txt"

        # Display the current iptables OUTPUT chain
        echo "Current iptables OUTPUT chain:"
        if ! iptables -nvL OUTPUT; then
            echo "Failed to display iptables rules."
            return "${_FAIL}"
        fi

        echo "iptables_exclude completed successfully."
        return "${_PASS}"
    }

    # Function to mount a VMDK file and handle multiple partitions
    function VMDKmount() {
        # The VMDK file to be mounted is passed as the first argument
        local vmdk_file="$1"

        # Base directory where partitions will be mounted
        local base_mount_dir="${ENGAGEMENT_DIR:-/tmp}/TASKS/RECON/SHARES/VMDK"

        # Counter to handle multiple partitions and create unique mount directories
        local count=1

        # Check if the VMDK file path was provided
        if [[ -z "${vmdk_file}" ]]; then
            echo "Error: Usage: VMDKmount <vmdk_file>"
            return "${_FAIL}"
        fi

        # Ensure the specified VMDK file exists
        if [[ ! -f "${vmdk_file}" ]]; then
            echo "Error: VMDK file '${vmdk_file}' does not exist."
            return "${_FAIL}"
        fi

        # Ensure the base mount directory exists, create it if necessary
        if [[ ! -d "${base_mount_dir}" ]]; then
            mkdir -p "${base_mount_dir}" || {
                echo "Error: Failed to create base mount directory '${base_mount_dir}'."
                return "${_FAIL}"
            }
        fi

        # Identify partitions in the VMDK file using guestfish
        echo "Info: Identifying partitions in ${vmdk_file}..."
        local partitions
        partitions="$(guestfish --ro -a "${vmdk_file}" run : list-partitions 2> /dev/null)" || {
            echo "Error: Failed to list partitions in '${vmdk_file}'."
            return "${_FAIL}"
        }

        # Ensure at least one partition is available in the VMDK file
        if [[ -z "${partitions}" ]]; then
            echo "Error: No partitions found in '${vmdk_file}'."
            return "${_FAIL}"
        fi

        # Array to store successfully mounted partitions
        local mount_points=()

        # Loop through each partition and attempt to mount it
        while IFS= read -r partition; do
            # Create a unique mount directory for each partition
            local mount_dir="${base_mount_dir}_partition_${count}"

            # Warn if the directory already exists but is not mounted
            if [[ -d "${mount_dir}" ]]; then
                if ! mount | grep -q "on ${mount_dir} "; then
                    echo "Warning: Directory ${mount_dir} exists but is not used for mounting."
                fi
            fi

            # Create the mount directory if it does not already exist
            mkdir -p "${mount_dir}" || {
                echo "Error: Failed to create mount directory '${mount_dir}'."
                continue
            }

            # Attempt to mount the partition as read-only
            echo "Info: Attempting to mount partition: ${partition}"
            if guestmount -a "${vmdk_file}" -m "${partition}" --ro "${mount_dir}"; then
                echo "Success: Mounted ${partition} to ${mount_dir}"
                mount_points+=("${mount_dir}")  # Add the successful mount point to the array
            else
                echo "Error: Failed to mount partition: ${partition}"
                rmdir "${mount_dir}" 2> /dev/null # Remove the directory if mount fails
            fi

            # Increment the counter for the next partition
            count=$((count + 1))
        done <<< "${partitions}"

        # Check if any partitions were successfully mounted
        if [[ ${#mount_points[@]} -eq 0 ]]; then
            echo "Error: Failed to mount any partitions from '${vmdk_file}'."
            return "${_FAIL}"
        fi

        # Display success message with all mounted partitions
        echo "Success: Mounted the following partitions from ${vmdk_file}:"
        for mount_dir in "${mount_points[@]}"; do
            echo "  - ${mount_dir}"
        done

        # Provide guidance for accessing the mounted file systems
        echo "Info: Access mounted file systems. Example:"
        echo "  secretsdump.py -sam <mount_point>/Windows/System32/config/SAM \\"
        echo "                  -system <mount_point>/Windows/System32/config/SYSTEM local"

        return "${_PASS}"
    }

    # Function to unmount all VMDK partitions
    function VMDKunmount() {
        # The base mount directory to unmount is passed as the first argument
        local base_mount_dir="$1"

        # Check if the base mount directory was provided
        if [[ -z "${base_mount_dir}" ]]; then
            fail "Usage: VMDKunmount <base_mount_dir>"
            return "${_FAIL}"
        fi

        # Ensure the base directory exists
        if [[ ! -d "${base_mount_dir}" ]]; then
            fail "Directory '${base_mount_dir}' does not exist."
            return "${_FAIL}"
        fi

        # Find all subdirectories in the base mount directory
        local mount_dirs=("${base_mount_dir%/}/"*/)
        if [[ ${#mount_dirs[@]} -eq 0 ]]; then
            fail "No mounted partitions found in '${base_mount_dir}'."
            return "${_FAIL}"
        fi

        # Loop through each subdirectory and unmount it
        for mount_dir in "${mount_dirs[@]}"; do
            # Check if the directory is currently mounted
            if mount | grep -q "on ${mount_dir} "; then
                info "Unmounting ${mount_dir}..."
                guestunmount "${mount_dir}" || {
                    fail "Failed to unmount '${mount_dir}'."
                    continue
                }
                pass "Successfully unmounted ${mount_dir}."
            else
                # If not mounted, skip the directory
                info "No filesystem is mounted on '${mount_dir}'. Skipping."
            fi

            # Remove the directory if it is empty
            if [[ -d "${mount_dir}" && -z "$(find "${mount_dir}" -mindepth 1 -print -quit)" ]]; then
                rmdir "${mount_dir}" && pass "Removed empty mount directory: ${mount_dir}"
            fi
        done

        return "${_PASS}"
    }

    function search_spider_plus_files() {
        local dir="/tmp/nxc_hosted/nxc_spider_plus"
        local file_types="txt|ps1|py|bat|sh|xls|xlsx|doc|docx|bak|conf|cfg"
        local search="password|secret|account|admin|ssh|pass"

        # Validate the directory exists
        if [[ ! -d "${dir}" ]]; then
            echo "Error: Directory '${dir}' does not exist."
            return 1
        fi

        # Perform the search
        grep -i -E "\.(${file_types})$" "${dir}"/* 2> /dev/null | grep -i -E "(${search})"
    }

    function search_in_spider_plus() {
        # IP address or identifier for the file
        local ip="$1"
        local search="password|secret|account|admin|ssh|pass"
        local file="/tmp/nxc_hosted/nxc_spider_plus/${ip}.json"

        # Validate that the file exists
        if [[ ! -f "${file}" ]]; then
            echo "Error: File '${file}' does not exist."
            return 1
        fi

        # Use environment variables or placeholders for credentials
        local username="${username:-user}"     # Default to "user" if $username is not set
        local password="${password:-pass}"     # Default to "pass" if $password is not set

        # Perform the search and check for matches
        local matches
        matches=$(grep -i -E "(^    \"|${search})" "${file}" | grep -B1 -iE "${search}")
        if [[ -z "${matches}" ]]; then
            echo "No matches found in ${file}."
            return 1
        fi

        # Process each matching line
        while read -r line; do
            if [[ "${line}" =~ ^\ {4}\"([^\"]+)\" ]]; then
                local share_name="${BASH_REMATCH[1]}"
                echo "Found share: ${share_name} in ${file}"
                echo "mount -t cifs -o username=${username},password=${password} //${ip}/${share_name} ${SHARES_DIR}/smb/mnt"
            fi
        done <<< "${matches}"
    }
fi
