#!/usr/bin/env bash
set -uo pipefail

# =============================================================================
# NAME        : run_internal_recon.sh
# DESCRIPTION :
# AUTHOR      : Adam Compton
# DATE CREATED: 2024-12-09 13:49:51
# =============================================================================
# EDIT HISTORY:
# DATE                 | EDITED BY    | DESCRIPTION OF CHANGE
# ---------------------|--------------|----------------------------------------
# 2024-12-09 13:49:51  | Adam Compton | Initial creation.
# =============================================================================

# Define script categories
script_categories["run_internal_recon"]="internal"

# Define an approximate ordering
script_order["run_internal_recon"]=1

# Main function
function run_internal_recon() {
    # =============================================================================
    # Step 1: Validate environment variables
    # =============================================================================
    local _env_vars
    _env_vars=("NETWORK_IFACE" "ENGAGEMENT_DIR")
    validate_envs "${_env_vars[@]}" || return 1

    # =============================================================================
    # Step 2: Validate input files and output directories
    # =============================================================================
    local _input_files
    local _output_dirs
    _input_files=("${ENGAGEMENT_DIR}/targets.txt")
    _output_dirs=("${ENGAGEMENT_DIR}/RECON")
    validate_input_output _input_files _output_dirs || return 1

    # =============================================================================
    # Step 3: Validate any needed tools exist
    # =============================================================================
    validate_tools "nmap" "grep" "awk" "nslookup" "sed"

    # =============================================================================
    # Step 4: Main logic
    # =============================================================================
    TARGETS_FILE="${ENGAGEMENT_DIR}/targets.txt"
    RECON_DIR="${ENGAGEMENT_DIR}/RECON"

    if [[ -z "${NETWORK_IFACE}" ]]; then
        info "NETWORK_IFACE is not set. Selecting an interface..."
        # Call a helper script or function to fetch interfaces
        interfaces=$(ip -o link show | awk -F': ' '{print $2}')
        NETWORK_IFACE=$(echo "${interfaces}" | fzf --prompt="Select a network interface: ")

        if [[ -n "${NETWORK_IFACE}" ]]; then
            info "Selected interface: ${NETWORK_IFACE}"
            export NETWORK_IFACE
            update_pentest_env "NETWORK_IFACE" "${NETWORK_IFACE}"
        else
            fail "No interface selected. Exiting."
            return
        fi
    fi

    ###############################################################################
    # Run all of the Nmap broadcast discovery scripts one at a time,
    # save each to its own file, and parse out the fields you care about.
    ###############################################################################

    # List your scripts (no “.nse” suffix here)
    NMAP_BCAST_SCRIPTS=(
        broadcast-ataoe-discover
        broadcast-bjnp-discover
        broadcast-db2-discover
        broadcast-dhcp-discover
        broadcast-dhcp6-discover
        broadcast-dns-service-discovery
        broadcast-dropbox-listener
        broadcast-eigrp-discovery
        broadcast-hid-discoveryd
        broadcast-igmp-discovery
        broadcast-jenkins-discover
        broadcast-listener
        broadcast-ms-sql-discover
        broadcast-netbios-master-browser
        broadcast-networker-discover
        broadcast-novell-locate
        broadcast-ospf2-discover
        broadcast-pc-anywhere
        broadcast-pc-duo-discover
        broadcast-pim-discovery
        broadcast-ping
        broadcast-pppoe-discover
        broadcast-rip-discover
        broadcast-ripng-discover
        broadcast-sonicwall-discover
        broadcast-sybase-asa-discover
        broadcast-tellstick-discover
        broadcast-upnp-info
        broadcast-versant-locate
        broadcast-wake-on-lan
        broadcast-wpad-discover
        broadcast-wsdd-discover
        broadcast-xdmcp-discover
    )

    for script in "${NMAP_BCAST_SCRIPTS[@]}"; do
        info "Running Nmap ${script} on interface ${NETWORK_IFACE}..."
        OUTPUT_FILE="${RECON_DIR}/${script}.txt"

        # Run it, tee to its own file, and capture the output for parsing
        NMAP_OUTPUT=$(nmap -e "${NETWORK_IFACE}" \
            --script "${script}" \
            --script-args broadcast-listener.timeout=300 \
            | tee -a "${OUTPUT_FILE}")

        # Now harvest the bits you care about from $NMAP_OUTPUT
        case "${script}" in

            broadcast-dhcp-discover)
                # Extract domain and DNS information
                AD_DOMAIN=$(echo "${NMAP_OUTPUT}" \
                    | grep "Domain Name:" \
                    | awk '{print $NF}' \
                    | tr -d '\\\x00')
                DNS_SERVER=$(echo "${NMAP_OUTPUT}" \
                    | grep "Domain Name Server:" \
                    | awk -F ', ' '{print $1}' \
                    | awk '{print $NF}')

                if [[ -z "${AD_DOMAIN}" || -z "${DNS_SERVER}" ]]; then
                    fail "Failed to extract domain or DNS server information from Nmap output."
                    return
                fi

                # Export and log the extracted variables
                export AD_DOMAIN DNS_SERVER
                update_pentest_env "AD_DOMAIN" "${AD_DOMAIN}"
                update_pentest_env "DNS_SERVER" "${DNS_SERVER}"
                info "AD_DOMAIN: ${AD_DOMAIN}"
                info "DNS_SERVER: ${DNS_SERVER}"

                # Derive DNS_DOMAIN from AD_DOMAIN
                DNS_DOMAIN="${AD_DOMAIN}"
                update_pentest_env "DNS_DOMAIN" "${DNS_DOMAIN}"
                info "DNS_DOMAIN: ${DNS_DOMAIN}"

                # Save domain information to file
                DOMAINS_FILE="${RECON_DIR}/DOMAINS.txt"
                echo "${AD_DOMAIN}" > "${DOMAINS_FILE}"
                update_pentest_env "DOMAINS_FILE" "${DOMAINS_FILE}"
                ;;
            *)
                echo "No parser defined for ${script}, skipping additional parsing."
                ;;
        esac

    done

    # Perform nslookup to retrieve LDAP SRV records
    info "Performing nslookup for LDAP SRV records..."
    NSLOOKUP_OUTPUT=$(nslookup -type=srv _ldap._tcp.dc._msdcs."${AD_DOMAIN}" "${DNS_SERVER}" | tee -a "${RECON_DIR}/nslookup_ldap.txt")

    if [[ $? -ne 0 ]]; then
        fail "Nslookup failed for domain ${AD_DOMAIN}."
        return
    fi

    # Extract FQDNs and save to file
    FQDN_FILE="${RECON_DIR}/DC_FQDN.txt"
    echo "${NSLOOKUP_OUTPUT}" | grep "_ldap._tcp.dc._msdcs.${AD_DOMAIN}" | awk '{print $NF}' | sed 's/\.$//' > "${FQDN_FILE}"

    if [[ ! -s "${FQDN_FILE}" ]]; then
        fail "No FQDNs found for domain ${AD_DOMAIN}."
        return
    fi

    info "FQDNs saved to ${FQDN_FILE}."
    update_pentest_env "DC_FQDN_FILE" "${FQDN_FILE}"

    # Extract first DC FQDN and set it as DC_FQDN
    DC_FQDN=$(head -n 1 "${FQDN_FILE}")

    if [[ -z "${DC_FQDN}" ]]; then
        fail "No DC FQDN found."
        return
    fi

    export DC_FQDN
    update_pentest_env "DC_FQDN" "${DC_FQDN}"

    # Ensure input file exists
    if [[ ! -f "${FQDN_FILE}" ]]; then
        echo "Error: FQDN file '${FQDN_FILE}' not found."
        return
    fi

    # Map FQDNs to IP addresses
    IP_FILE="${RECON_DIR}/DC_IP.txt"
    true > "${IP_FILE}"

    while read -r fqdn; do
        # Skip empty lines
        [[ -z "${fqdn}" ]] && continue

        # Perform DNS lookup and extract the last IPv4 address
        ip=$(nslookup "${fqdn}" 2> /dev/null | awk '/^Address: / {ip=$2} END {print ip}')

        if [[ -n "${ip}" ]]; then
            echo "${ip}" >> "${IP_FILE}"
        else
            echo "Warning: Failed to resolve ${fqdn}" >&2
        fi
    done < "${FQDN_FILE}"

    info "Mapped FQDNs to IPs and saved to ${IP_FILE}."
    update_pentest_env "DC_IP_FILE" "${IP_FILE}"

    # Extract first DC IP and set it as DC_IP
    DC_IP=$(head -n 1 "${IP_FILE}")

    if [[ -z "${DC_IP}" ]]; then
        fail "No DC IP found."
        return
    fi

    export DC_IP
    update_pentest_env "DC_IP" "${DC_IP}"

    # Success message
    pass "Recon completed successfully!"
}
